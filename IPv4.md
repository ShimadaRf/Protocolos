# Header IPv4 -
## Visão Geral -
O cabeçalho IPv4 é a parte frontal, essencial e compacta de cada datagrama que trafega pela internet, agindo como o envelope que guia a informação da origem ao destino. Sua estrutura básica é de 20 bytes e contém os dados cruciais que definem como o pacote deve ser roteado. Os primeiros campos incluem a versão, sempre 4 para este protocolo, e o IHL (Internet Header Length), que informa o tamanho total do cabeçalho. Em seguida, o campo tipo de serviço permite que roteadores priorizem o tráfego conforme a necessidade. O comprimento total indica o tamanho completo do pacote, enquanto os campos de identificação, flags e fragment offset são dedicados à fragmentação, permitindo que pacotes grandes sejam divididos para passar por redes com limitações de tamanho e, depois, remontados corretamente no destino. O TTL (time to live) é um contador de hops que evita que pacotes circulem em loops infinitos, ele é decrementado em cada roteador e o pacote é descartado ao chegar a zero. O campo protocolo é vital, pois informa qual protocolo da camada de transporte (como TCP ou UDP) está contido na área de dados, e o Checksum é usado para garantir a integridade do próprio cabeçalho. Por fim, temos os campos de endereços IP de origem e destino, cada um com 32 bits, que definem quem enviou e quem deve receber o pacote.  
O header segue o padrão de formação abaixo:
  
<img src="imagens\headeripv4.png" alt="Header IPv4" width="700" style="border-radius: 30px;">  
   
Este conjunto de informações não apenas facilita o roteamento, mas também possui uma importância central na cibersegurança. A manipulação dos campos do cabeçalho IPv4 é um vetor comum para ataques de negação de serviço e evasão de sistemas de segurança. Por exemplo, a falsificação do endereço de origem (IP Spoofing) permite que um atacante se mascare ou realize ataques de amplificação, sobrecarregando uma vítima com tráfego refletido, é difícil imaginar um cenário onde um bom pentester não conheça a fundo os headers dos protocolos. Os campos de fragmentação podem ser explorados para contornar firewalls e IDS que não são capazes de reassemblar corretamente os pacotes para inspeção, permitindo que payloads maliciosos passem despercebidos. Por outro lado, a inspeção rigorosa desses mesmos campos é a base de todas as defesas de rede, incluindo regras de firewall baseadas no endereço de origem/destino e a análise do campo protocolo por sistemas IDS para identificar tráfego anômalo ou malicioso, tornando o cabeçalho IPv4 o principal ponto de controle e monitoramento no tráfego de rede.
A ideia desse tópico é explorar a fundo os campos do header IP e trazer a importância deles para a segurança. Abaixo temos algumas vulnerabilidades que podem ser exploradas, diretamente ou indiretamente, do header estudado.

1. Spoofing  
Os campos mais explorados são os de endereçamento. A principal ameaça é o IP Spoofing, onde o atacante falsifica o endereço IP de origem. Isso é usado para ocultar a identidade do agressor ou para lançar ataques de reflexão e amplificação, onde as respostas de servidores legítimos são direcionadas ao endereço falsificado da vítima, sobrecarregando-a. O endereço IP de destino, embora geralmente legítimo, pode ser alvo em ataques man-in-the-middle  locais, onde o roteamento é manipulado para desviar o pacote.
2. Vulnerabilidades de controle e qualidade  
O campo TTL, embora protetor contra loops infinitos, pode ser usado ofensivamente. Ao observar os valores de TTL em pacotes de resposta, um atacante pode realizar a engenharia reversa da topologia da rede, inferindo o número de hops até o alvo. O campo protocolo (que indica se o pacote é TCP, UDP, etc.) é crucial para firewalls, mas um valor inválido ou inesperado pode ser enviado para tentar causar ineficiências ou falhas em sistemas legados. Já o campo type of service pode ser manipulado para tentar forçar o tráfego malicioso a receber uma alta prioridade (QoS) na rede, prejudicando a latência do tráfego legítimo.
3. Riscos de Integridade e Malformação  
O header checksum, que visa garantir a integridade do cabeçalho, é limitado, um atacante pode facilmente recalcular o checksum para um cabeçalho que contenha informações ofensivas, pois ele não verifica a integridade do payload. Além disso, a manipulação de campos de controle de tamanho pode causar negação de serviço, valores malformados para a versão (diferente de 4), o IHL, ou o total length podem fazer com que sistemas, especialmente os mais antigos, falhem, congelem ou tentem ler fora dos limites da memória, causando buffer overflows.
4. Ameaças da Fragmentação  
Os campos de fragmentação (identification, flags e fragment offset) representam um grande risco de evasão. Eles são explorados em ataques como teardrop e com o uso de fragmentos sobrepostos (Overlapping Fragments). Nestes ataques, o invasor envia pedaços de dados que, quando remontados, sobrecarregam o sistema de destino ou, pior, resultam em pacotes que contornam a inspeção de firewalls e IDS. Por exemplo, um fragmento pode ser intencionalmente pequeno, contendo apenas o início do cabeçalho TCP/UDP, forçando o firewall a inspecionar apenas informações incompletas e permitindo que o payload malicioso passe despercebido.
5. Exploração das Opções  
O campo options, embora menos comum, é vulnerável. Se a opção source routing estiver habilitada, um atacante pode especificá-la para forçar o pacote a seguir um caminho específico na rede, ignorando as regras de roteamento padrão e potencialmente acessando segmentos de rede protegidos.

## Version -
O version é o primeiro campo do cabeçalho de um datagrama IP, ele tem 4 bits em seu campo, e possui uma função crítica na arquitetura de rede, ele determina a sintaxe e a semântica do restante do cabeçalho do datagrama. Especificamente, o valor contido no campo version indica a versão do protocolo IP à qual o datagrama em questão adere, e essa informação é fundamental para qualquer nó de rede (roteadores, firewalls e o hospedeiro destinatário) que receba o pacote, pois a estrutura e o significado dos campos subsequentes no cabeçalho variam drasticamente entre as versões. Para o IPv4, o campo version contém o valor binário 0100 (decimal 4), o que instrui o dispositivo a interpretar o datagrama de acordo com o formato estabelecido pela RFC 791 e suas extensões, enquanto para o IPv6, o campo contém o valor binário 0110 (decimal 6), exigindo a interpretação da estrutura simplificada e modificada definida pela RFC 8200. Ao ser o primeiro campo a ser examinado, o version permite que os dispositivos de processamento de pacotes despachem o datagrama para o módulo de software ou hardware apropriado para análise e encaminhamento, o que é um componente chave do mecanismo de fast-path ou forwarding dentro dos roteadores, minimizando a latência e garantindo a interoperabilidade. A existência deste campo na posição inicial viabiliza a transição gradual e a coexistência de múltiplas versões do IP na infraestrutura global da Internet, permitindo que roteadores inspecionem o campo e decidam se o datagrama deve ser encaminhado (potencialmente via tunnel), processado nativamente ou descartado se a versão não for suportada, assegurando a evolução contínua da rede sem interrupção.

Embora o campo de versão no cabeçalho IPv4 ocupe apenas 4 bits e pareça ter uma função estática, ele desempenha um papel tático interessante na cibersegurança quando manipulado ou analisado profundamente. Do ponto de vista defensivo, esse campo atua como o primeiro filtro de sanidade em qualquer dispositivo de rede. Como a especificação exige que o valor seja estritamente 4, firewalls e sistemas de detecção de intrusão (IDS) utilizam essa verificação como uma forma de triagem rápida. Se um pacote chega com qualquer valor diferente, ele pode ser descartado imediatamente no nível do hardware ou do driver, economizando ciclos da CPU que seriam gastos analisando o restante do cabeçalho ou a carga útil. Portanto, a defesa utiliza a imutabilidade desse campo para garantir a eficiência e detectar anomalias. Um alerta de "versão de IP inválida" em um monitoramento é **quase** sempre um indicador de alta fidelidade de que alguém está utilizando ferramentas de injeção de pacotes customizados na rede, pois sistemas operacionais legítimos não cometem esse erro naturalmente.

Na perspectiva ofensiva, a manipulação do campo version pode ser utilizada para testar a robustez dos analisadores de pacotes (parsers) ou para tentar evasão de segurança. Atacantes podem empregar técnicas de fuzzing, enviando pacotes com versões inválidas (como 0, 5 ou 15) para tentar causar uma negação de serviço (DoS) em equipamentos legados ou mal programados, que podem entrar em falha ao tentar processar um valor inesperado em vez de descartá-lo corretamente. Além disso, existe a técnica de desincronização de interpretação, onde um atacante tenta enganar um firewall para que ele ignore o pacote (achando, por exemplo, que é um tráfego IPv6 malformado), enquanto o sistema alvo vulnerável processa o pacote malicioso.

Ainda no cenário ofensivo e de reconhecimento, o campo serve para técnicas de fingerprinting ativo e canais encobertos. No fingerprinting, o atacante envia propositalmente um pacote com versão incorreta para analisar como o alvo responde, um sistema Windows pode simplesmente silenciar, enquanto um roteador Cisco ou um servidor Linux podem enviar uma mensagem de erro ICMP específica. Essa diferença de comportamento ajuda o atacante a mapear qual sistema operacional está rodando do outro lado sem precisar de um scan agressivo. Já em canais encobertos, dois dispositivos comprometidos dentro de uma rede podem se comunicar usando valores de versão inválidos como sinais de comando e controle, como a maioria dos dispositivos de rede descarta esses pacotes sem registrá-los profundamente nos logs de aplicação, essa comunicação pode passar despercebida por administradores que não estejam analisando o tráfego bruto no nível do cabo.

**Obs:** RFC significa Request for Comments. Os padrões mencionados no texto, RFC 791 e RFC 8200 são, basicamente, o nome do documento oficial que define o IPv4 e o IPv6, respectivamente. Eles agem para padronizar e criar uma "constituição" do protocolo que precisa ser seguida por todos que desejam utilizá-las. Sendo assim, a gente pode ver os protocolos IPv4 e IPv6 como produtos desse manual.

## IHL -
O campo Internet Header Length está localizado nos quatro bits menos significativos do primeiro byte do cabeçalho IPv4, compartilhando o octeto inicial com o campo version. Esse campo desempenha uma função arquitetural crítica, ele define a fronteira estrutural entre os metadados de roteamento e do payload do pacote. Diferente de contadores de tamanho convencionais que operam em bytes, o IHL utiliza uma unidade de medida baseada em "palavras" de 32 bits (ou 4 bytes). Essa escolha de design reflete a necessidade histórica e computacional de alinhamento de memória, garantindo que o processamento do cabeçalho seja otimizado pela CPU.

A aritmética do IHL impõe limites rígidos ao protocolo. Como o valor é interpretado multiplicando-se o binário por 4, o menor valor funcional aceitável é 5 (0101), o que corresponde aos 20 bytes obrigatórios de um cabeçalho IPv4 padrão sem opções extras. No outro extremo, sendo um campo de 4 bits, seu valor máximo é 15 (1111), permitindo um cabeçalho de até 60 bytes. A diferença entre o mínimo (20 bytes) e o máximo (60 bytes) é reservada para o campo options e seu respectivo padding.

Do ponto de vista da cibersegurança e da engenharia de redes, o IHL atua como um offset vital para o sistema operacional. Ele instrui a pilha TCP/IP exatamente onde iniciar a leitura dos protocolos de camada superior (como TCP ou UDP). Qualquer inconsistência neste valor gera vetores de risco: um IHL menor que 5 classifica o pacote como malformado, resultando em descarte imediato ou erros de processamento; já um IHL inflado artificialmente, sem a presença real de opções, pode indicar uma tentativa de covert channel (canal encoberto), onde um atacante utiliza o espaço excedente do cabeçalho para trafegar dados ocultos ou comandos maliciosos, evadindo inspeções superficiais de firewall que focam apenas no payload.

## Fragment Offset -
O campo Fragment Offset foi concebido juntamente com o próprio internet protocol (IP) na década de 1970. Esse conceito surgiu da necessidade de interoperabilidade entre redes com diferentes capacidades. No final dos anos 1970 e início dos anos 1980, o protocolo IP foi projetado para rodar sobre diversas tecnologias de camada de enlace. O problema é que cada uma dessas tecnologias impõe um maximum transmission unit (MTU), ou seja, um tamanho máximo de pacote. Isso nos levou a pensar no que fazer caso um datagrama gerado em uma rede com um MTU alto precisasse atravessar uma rede com um MTU baixo. Os arquitetos do IP, principalmente Jon Postel e Vint Cerf, decidiram que os roteadores intermediários teriam a responsabilidade de quebrar, em outras palavras, fragmentar o pacote em pedaços menores. Para permitir que o destino remontasse os pedaços na ordem correta, foi criado o campo fragment offset, ele indica a posição de início dos dados contidos naquele fragmento em relação ao payload do datagrama original.

O cabeçalho IPv4 foi projetado para ser o mais compacto possível, com apenas 20 bytes obrigatórios e o espaço destinado ao fragment offset no cabeçalho é de apenas 16 bits, sendo que 3 deles são reservados para as flags, já discutidas anteriormente, e os outros 13 para o fragment offset. Esse número extremamente baixo se dá pela grande escassez de recursos, estamos falando de uma época onde cada mínimo bit importava, as restrições de hardware eram extremas. Esse número extremamente baixo de bits acarretou em alguns problemas. O maior valor binário que o campo do fragment offset poderia representar seria de 2¹³ = 8191. O problema é que o tamanho máximo de um datagrama IPv4 é de 65.535 bytes, ou seja, como o fragment offset pode dizer onde cada pacote vai começar e terminar se o limite máximo dele é de 8191? A solução foi mais simples do que se pode imaginar, é só multiplicar por 8, ou seja, se o valor do campo offset é de 185, sabemos que esse pacote começa no byte 1480. Isso explica o porquê de o campo fragment offset não ser sequencial, ele não diz a ordem dos pacotes, mas, na verdade, a posição inicial dos bytes daquele payload, pensar nele como um mapa me ajudou na compreensão.

Para calcular como o fragment offset é determinado, o processo é bem simples e realmente depende de apenas três números: o tamanho total do payload, o tamanho do cabeçalho IP (geralmente 20 bytes no IPv4) e o MTU da rede. Pensemos no seguinte exemplo, se temos um payload de 5000 bytes, um cabeçalho de 20 bytes e um MTU de 1500 bytes, o primeiro passo é, de fato, remover o tamanho do cabeçalho da MTU para descobrir o tamanho máximo de dados reais que cada fragmento pode carregar. Isso nos dá 1500 - 20 = 1480 por fragmento.

O segredo aqui é que o fragment offset é medido em unidades de 8 bytes. Por isso, o tamanho dos dados que você está enviando em cada fragmento (os 1480 bytes) precisa ser um múltiplo de 8, o que 1480 é (1480 / 8 = 185).

Daí, é só dividir o payload total pelos fragmentos de 1480 bytes: 5000 dividido por 1480 resulta em três fragmentos completos e um resto.

1. O primeiro fragmento carrega os primeiros 1480 bytes. Seu deslocamento (offset) é 0 / 8 = 0.
2. O segundo fragmento começa no byte 1480. Seu deslocamento é 1480 / 8 = 185.
3. O Terceiro Fragmento começa no byte 2960 (1480 + 1480). Seu deslocamento é 2960 / 8 = 370.
4. O último fragmento começa no byte 4440 (2960 + 1480) e carrega os 560 bytes restantes. Seu deslocamento é 4440 / 8 = 555.

<img src="imagens\calcfo1.png" alt="Calculo F.O." width="500" style="border-radius: 3px;">

O fragment offset é, portanto, o ponto de partida dos dados de cada fragmento, expresso em múltiplos de 8. Ele informa ao receptor exatamente onde o bloco de dados daquele pacote se encaixa no payload original de 5000 bytes para que ele possa ser reconstruído corretamente.

Apesar de sua engenhosidade, o mecanismo de fragmentação do IPv4 introduz uma complexidade indesejada, gerando sobrecarga de processamento nos roteadores e no host de destino. No contexto da cibersegurança, o fragment offset é fundamental em técnicas de evasão de IDS/IPS, como o tiny fragment attack e a sobreposição maliciosa de fragmentos, também conhecida como overlap. O manuseio inconsistente da remontagem em diferentes stacks TCP/IP é uma vulnerabilidade conhecida, sendo um dos motivos pelos quais o IPv6 praticamente eliminou a fragmentação intermediária, aderindo estritamente ao princípio end-to-end.
